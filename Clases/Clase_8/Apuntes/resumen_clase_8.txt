Resumen General: Multiprocessing en Python


ğŸ§© a) Fundamentos de procesos y concurrencia

    Proceso: unidad de ejecuciÃ³n independiente con su propio espacio de memoria.

    Hilo (thread): unidad mÃ¡s ligera que comparte memoria con otros hilos del mismo proceso.

    Multiprocessing: permite ejecutar mÃºltiples procesos en paralelo (aprovecha varios nÃºcleos).

    â— Python tiene el GIL (Global Interpreter Lock) que limita la ejecuciÃ³n paralela de hilos, pero no afecta a procesos.

    Ciclo de vida de un proceso:

        CreaciÃ³n â†’ Inicio (start()) â†’ EjecuciÃ³n â†’ FinalizaciÃ³n â†’ Espera del padre (join())

âš™ï¸ b) CreaciÃ³n y gestiÃ³n de procesos

    Usamos multiprocessing.Process()

    MÃ©todos importantes:

        start(): inicia el proceso.

        join(): espera a que termine.

        is_alive(): verifica si sigue activo.

        current_process(): permite acceder a nombre, PID, etc.

ğŸ”„ c) ComunicaciÃ³n entre procesos

    Â¿Por quÃ©?: Cada proceso tiene su propia memoria, por lo que no comparten variables.

    Pipes:

        ComunicaciÃ³n entre dos procesos solamente.

        EnvÃ­o y recepciÃ³n por extremos (conn1.send(), conn2.recv()).

    Queues:

        Permiten comunicaciÃ³n entre varios procesos.

        Funcionan como una cola segura entre procesos.

    âœ… Preferir Queue para sistemas con mÃ¡s de dos procesos.

ğŸ” d) SincronizaciÃ³n bÃ¡sica con Lock

    â— Problema: condiciones de carrera cuando mÃºltiples procesos acceden/modifican la misma variable.

    SoluciÃ³n: Lock

        lock.acquire() / lock.release()

        O usar con with lock:

    Se utiliza en secciones crÃ­ticas para que solo un proceso a la vez acceda al recurso.

ğŸ§µ e) Pool de procesos

    Para manejar grandes cantidades de procesos fÃ¡cilmente.

    Se crea con: with Pool(processes=n) as pool:

    MÃ©todos Ãºtiles:

        map(): paraleliza sobre un iterable.

        apply(): como una funciÃ³n normal.

        map_async() / apply_async(): ejecuciÃ³n asincrÃ³nica.

    Ventaja: menos cÃ³digo repetido, mejor gestiÃ³n.

ğŸ“¦ f) Memoria compartida bÃ¡sica

    Python permite compartir memoria entre procesos con:

        Value: para un solo dato (ej. un contador).

        Array: para listas de datos.

    Requieren especificar tipo de dato ('i' para int, 'd' para float, etc.)

    Pueden sincronizarse con get_lock() o manualmente con Lock.

âœ… Ejercicio Final: mp_worker.py

    Pasaste un cÃ³digo secuencial a uno paralelo real, viendo cÃ³mo:

        Se reduce el tiempo total de ejecuciÃ³n.

        Cada proceso trabaja en paralelo.

ğŸ“˜ Preguntas de repaso final

    Â¿Por quÃ© multiprocessing puede ejecutar en paralelo real y threading no?

    Â¿CuÃ¡l es la diferencia prÃ¡ctica entre QuePipe?

    Â¿QuÃ© problema soluciona el Lock y quÃ© pasa si no se usa?

    Â¿CuÃ¡ndo conviene usar Pool en vez de Process manual?